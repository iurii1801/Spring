# Лабораторная №2 Spring Boot приложение для управления библиотекой

## Введение

Данный проект представляет собой RESTful приложение, разработанное на Spring Boot, для управления библиотекой. Оно реализует 3 контроллера, 3 сервиса и 5 взаимосвязанных сущностей. Основной упор сделан на архитектурную раздельность, использование DTO вместо прямой работы с Entity, и соблюдение условий переиспользования логики из первой лабораторной работы.

## Цели работы

- Реализовать полноценное CRUD-приложение для управления библиотечными объектами.
- Использовать Hibernate (через Spring Data JPA) для работы с базой данных (MSSQL).
- Взаимодействовать с клиентом через DTO.
- Обеспечить тестируемость через Swagger и HTTP-запросы.

## Используемые технологии

- **Spring Boot 3.4.4**
- **Spring Web** (REST API)
- **Spring Data JPA** (ORM)
- **MSSQL Server** (база данных)
- **Lombok** (генерация кода)
- **Swagger (springdoc-openapi)** — визуализация API
- **Maven** — система сборки

## Архитектура проекта

### Слои приложения

- **Controller** — REST API интерфейс
- **Service** и **impl** — бизнес-логика
- **Repository** — слой доступа к данным через JPA
- **DTO** — объекты передачи данных
- **Entity** — сущности и их связи

### Структура пакетов

```sh
com.example.librarymanagement
├── controller
├── dto
├── entity
├── repository
├── service
│   └── impl
```

## Сущности и связи

### Author

Сущность, представляющая автора книг. Содержит поля `id` и `name`. Один автор может написать много книг.

- Связь: **One-to-Many** с `Book`
- В `Book` хранится внешний ключ `author_id`

### Publisher

Сущность издателя. Содержит поля `id` и `name`. Один издатель может издавать множество книг.

- Связь: **One-to-Many** с `Book`
- В `Book` хранится внешний ключ `publisher_id`

### Category

Сущность категории, к которой могут принадлежать книги. Содержит поля `id` и `name`. Одна категория может быть связана с несколькими книгами, и наоборот.

- Связь: **Many-to-Many** с `Book`
- Используется связующая таблица `book_category`

### Book

Центральная сущность, представляющая книгу. Содержит поля `id`, `title`, а также ссылки на автора, издателя и список категорий.

- **Many-to-One** к `Author` и `Publisher`
- **Many-to-Many** к `Category`
- `Book` является владельцем связей (хранит внешние ключи)

### Library

Сущность, представляющая библиотеку. Содержит `id`, `location` и список книг, находящихся в этой библиотеке.

- Связь: **One-to-Many** с `Book` (или можно использовать `ElementCollection`, если книги — не сущности, но в данном случае используются именно сущности)

## DTO и работа с данными

Каждая сущность имеет свой DTO:

- Передаётся только нужная информация (например, ID связей)
- DTO используются во всех контроллерах
- Преобразование выполняется в сервисах

## CRUD Операции и тестирование

### Способы тестирования

- **Swagger UI:** `http://localhost:8080/swagger-ui/index.html`
- **IntelliJ .http файл:** `src/main/resources/test.http`

### Операции поддерживаются для

- `/api/authors`
- `/api/publishers`
- `/api/books`

## Примеры запросов (см. test.http)

- GET всех авторов, книг, издателей
- POST — создание нового объекта
- PUT — обновление
- DELETE — удаление

## Как запустить проект

1. Установить MSSQL и создать базу `library_DB`
2. Убедиться, что указаны корректные логин/пароль в `application.properties`
3. Собрать проект с помощью Maven
4. Запустить `LibraryManagementApplication`
5. Перейти на [http://localhost:8080/swagger-ui/index.html](http://localhost:8080/swagger-ui/index.html) для тестирования

## Другие детали

**Почему используется DTO, а не Entity напрямую?**

Это позволяет изолировать внутреннюю структуру базы данных от внешнего API. DTO упрощают сериализацию, предотвращают избыточную передачу данных и защищают от случайного изменения сущностей.

**Почему только 3 контроллера, если сущностей 5?**

Согласно условиям лабораторной работы, требуется реализовать только 3 контроллера. Остальные сущности участвуют как связанные объекты и обрабатываются через сервисный слой.

**Почему `Library` реализована через `OneToMany`, а не `@ElementCollection`?**

Потому что `Book` — это полноценная сущность, а `@ElementCollection` используется только для встраиваемых (Embeddable) типов. Использование `OneToMany` обеспечивает корректную работу с внешними ключами и связями.

**Какие аннотации используются для описания связей между сущностями?**

Используются аннотации JPA: `@OneToMany`, `@ManyToOne`, `@ManyToMany`, `@JoinColumn` и `@JoinTable`. Они позволяют явно описать типы связей и таблицы, участвующие в связях.

**Как передаются связанные сущности в DTO?**

Вместо вложенных объектов в DTO передаются только их `id`. Затем в сервисах по этим ID загружаются связанные сущности из репозиториев.

**Почему `PUT` запросы принимают `id` и в теле, и в URL?**

`id` в `URL` — для идентификации ресурса. В теле объекта `id` не обязателен, но может быть добавлен для ясности. В логике сервиса основным идентификатором служит `id` из `URL`.

# Лабораторная №2: Spring Boot приложение для управления библиотекой (DAO-реализация)

## Введение

Данный проект представляет собой RESTful приложение, разработанное на Spring Boot, для управления библиотекой. Оно реализует 3 контроллера, 3 сервиса и 5 взаимосвязанных сущностей. Основной упор сделан на архитектурную раздельность, использование DTO вместо прямой работы с Entity, и реализацию собственного слоя DAO на основе `EntityManager`, **без использования Spring Data JPA репозиториев**.

## Цели работы

- Реализовать полноценное CRUD-приложение для управления библиотечными объектами.
- Использовать `EntityManager` через собственные DAO-реализации вместо `JpaRepository`.
- Взаимодействовать с клиентом через DTO.
- Обеспечить тестируемость через Swagger и HTTP-запросы.

## Используемые технологии

- **Spring Boot 3.4.4**
- **Spring Web** (REST API)
- **Jakarta Persistence (JPA)** с `EntityManager`
- **MSSQL Server** (база данных)
- **Lombok** (генерация кода)
- **Swagger (springdoc-openapi)** — визуализация API
- **Maven** — система сборки

## Архитектура проекта

### Слои приложения

- **Controller** — REST API интерфейс
- **Service + Impl** — бизнес-логика
- **Repository** — интерфейсы DAO и их реализации (`DaoImpl`) с `EntityManager`
- **DTO** — объекты передачи данных
- **Entity** — сущности и их связи

### Структура пакетов

```sh
com.example.librarymanagement
├── controller
├── dto
├── entity
├── repository
│   ├── AuthorDao.java
│   ├── AuthorDaoImpl.java
│   └── ...
├── service
│   ├── BookService.java
│   └── impl
│       ├── BookServiceImpl.java
│       └── ...
```

## Сущности и связи

### Author

Сущность, представляющая автора книг. Один автор может написать множество книг.

- Связь: **One-to-Many** с `Book` (в `Book` — внешний ключ `author_id`)

### Publisher

Сущность издателя. Один издатель может издавать множество книг.

- Связь: **One-to-Many** с `Book` (в `Book` — внешний ключ `publisher_id`)

### Category

Сущность категории. Одна категория может быть связана с несколькими книгами, и наоборот.

- Связь: **Many-to-Many** с `Book` через таблицу `book_category`

### Book

Центральная сущность, представляющая книгу.

- Поля: `id`, `title`, `author`, `publisher`, `categories`
- Связи: **Many-to-One** к `Author`, **Many-to-One** к `Publisher`, **Many-to-Many** к `Category`

### Library

Сущность, содержащая список книг.

- Связь: **One-to-Many** с `Book` (или `@ElementCollection`, но в данном случае используются полноценные сущности)

## DAO и EntityManager

Вместо использования `JpaRepository`, для каждой сущности созданы:

- DAO-интерфейсы (`AuthorDao`, `BookDao`, и т.д.)
- Их реализации (`AuthorDaoImpl`, `BookDaoImpl`, и т.д.) с `@PersistenceContext` и `EntityManager`

**Методы DAO:**

- `save(entity)`
- `update(entity)`
- `delete(id)`
- `findById(id)`
- `findAll()`

DAO внедряются в сервисы с помощью конструктора.

## DTO и работа с данными

- Используются отдельные DTO-классы для всех сущностей
- DTO передаёт только нужные поля (например, `authorId`, `publisherId`, `categoryIds`)
- Преобразование между DTO и Entity происходит в `*ServiceImpl`

## CRUD Операции и тестирование

### Способы тестирования

- **Swagger UI:**  
  [http://localhost:8080/swagger-ui/index.html](http://localhost:8080/swagger-ui/index.html)

- **IntelliJ `.http` файл:**  
  `src/main/resources/test.http`

### Примеры поддерживаемых запросов

- `GET /api/authors` — получить всех авторов
- `POST /api/books` — создать книгу
- `PUT /api/publishers/{id}` — обновить издателя
- `DELETE /api/books/{id}` — удалить книгу

## Как запустить проект

1. Установить MSSQL и создать базу `library_DB`
2. Указать логин и пароль в `application.properties`
3. Собрать проект через `Maven`
4. Запустить `LibraryManagementApplication`
5. Открыть Swagger: [http://localhost:8080/swagger-ui/index.html](http://localhost:8080/swagger-ui/index.html)

---

## Ответы на вопросы

**Почему не используется JpaRepository?**  
Чтобы продемонстрировать работу напрямую через `EntityManager` и собственные DAO-реализации, как требует условие лабораторной.

**Зачем использовать DTO?**  
Для отделения слоёв и безопасности. DTO скрывает структуру сущностей, упрощает передачу данных и защищает от утечек бизнес-логики.

**Почему только 3 контроллера?**  
Требование задания — реализовать 3 контроллера, остальные сущности участвуют как вложенные объекты.

**Как обрабатываются связи между сущностями?**  
Связи Many-to-One и Many-to-Many реализуются через JPA аннотации и таблицы связывания.

**Что делать, если сущность не найдена?**  
Методы DAO возвращают `null`, а сервисы могут выбрасывать `RuntimeException`, чтобы клиент получил понятный `404`.

**Как обрабатываются исключения, если сущность не найдена?**

В сервисах используется `orElseThrow(...)`, где можно выбрасывать `RuntimeException` или `ResponseStatusException` с кодом `404`. Это позволяет клиенту понять, что ресурс не найден.

**Как проверялась работа приложения?**

С помощью `.http` файла в `IntelliJ IDEA`, а также через `Swagger UI`. Оба способа позволяют полноценно протестировать все `CRUD`-операции.

## Вывод

В процессе выполнения лабораторной работы было реализовано полноценное REST API-приложение с использованием Spring Boot, DTO, JPA и MSSQL. Архитектура выстроена по слоям, связи между сущностями оформлены согласно требованиям, а функциональность протестирована через Swagger и встроенные HTTP-запросы.