# Лабораторная №2 Spring Boot приложение для управления библиотекой

## Введение

Данный проект представляет собой RESTful приложение, разработанное на Spring Boot, для управления библиотекой. Оно реализует 3 контроллера, 3 сервиса и 5 взаимосвязанных сущностей. Основной упор сделан на архитектурную раздельность, использование DTO вместо прямой работы с Entity, и соблюдение условий переиспользования логики из первой лабораторной работы.

## Цели работы

- Реализовать полноценное CRUD-приложение для управления библиотечными объектами.
- Использовать Hibernate (через Spring Data JPA) для работы с базой данных (MSSQL).
- Взаимодействовать с клиентом через DTO.
- Обеспечить тестируемость через Swagger и HTTP-запросы.

## Используемые технологии

- **Spring Boot 3.4.4**
- **Spring Web** (REST API)
- **Spring Data JPA** (ORM)
- **MSSQL Server** (база данных)
- **Lombok** (генерация кода)
- **Swagger (springdoc-openapi)** — визуализация API
- **Maven** — система сборки

## Архитектура проекта

### Слои приложения

- **Controller** — REST API интерфейс
- **Service** и **impl** — бизнес-логика
- **Repository** — слой доступа к данным через JPA
- **DTO** — объекты передачи данных
- **Entity** — сущности и их связи

### Структура пакетов

```sh
com.example.librarymanagement
├── controller
├── dto
├── entity
├── repository
├── service
│   └── impl
```

## Сущности и связи

### Author

Сущность, представляющая автора книг. Содержит поля `id` и `name`. Один автор может написать много книг.

- Связь: **One-to-Many** с `Book`
- В `Book` хранится внешний ключ `author_id`

### Publisher

Сущность издателя. Содержит поля `id` и `name`. Один издатель может издавать множество книг.

- Связь: **One-to-Many** с `Book`
- В `Book` хранится внешний ключ `publisher_id`

### Category

Сущность категории, к которой могут принадлежать книги. Содержит поля `id` и `name`. Одна категория может быть связана с несколькими книгами, и наоборот.

- Связь: **Many-to-Many** с `Book`
- Используется связующая таблица `book_category`

### Book

Центральная сущность, представляющая книгу. Содержит поля `id`, `title`, а также ссылки на автора, издателя и список категорий.

- **Many-to-One** к `Author` и `Publisher`
- **Many-to-Many** к `Category`
- `Book` является владельцем связей (хранит внешние ключи)

### Library

Сущность, представляющая библиотеку. Содержит `id`, `location` и список книг, находящихся в этой библиотеке.

- Связь: **One-to-Many** с `Book` (или можно использовать `ElementCollection`, если книги — не сущности, но в данном случае используются именно сущности)

## DTO и работа с данными

Каждая сущность имеет свой DTO:

- Передаётся только нужная информация (например, ID связей)
- DTO используются во всех контроллерах
- Преобразование выполняется в сервисах

## CRUD Операции и тестирование

### Способы тестирования

- **Swagger UI:** `http://localhost:8080/swagger-ui/index.html`
- **IntelliJ .http файл:** `src/main/resources/test.http`

### Операции поддерживаются для

- `/api/authors`
- `/api/publishers`
- `/api/books`

## Примеры запросов (см. test.http)

- GET всех авторов, книг, издателей
- POST — создание нового объекта
- PUT — обновление
- DELETE — удаление

## Как запустить проект

1. Установить MSSQL и создать базу `library_DB`
2. Убедиться, что указаны корректные логин/пароль в `application.properties`
3. Собрать проект с помощью Maven
4. Запустить `LibraryManagementApplication`
5. Перейти на [http://localhost:8080/swagger-ui/index.html](http://localhost:8080/swagger-ui/index.html) для тестирования

## Другие детали

**Почему используется DTO, а не Entity напрямую?**

Это позволяет изолировать внутреннюю структуру базы данных от внешнего API. DTO упрощают сериализацию, предотвращают избыточную передачу данных и защищают от случайного изменения сущностей.

**Почему только 3 контроллера, если сущностей 5?**

Согласно условиям лабораторной работы, требуется реализовать только 3 контроллера. Остальные сущности участвуют как связанные объекты и обрабатываются через сервисный слой.

**Почему `Library` реализована через `OneToMany`, а не `@ElementCollection`?**

Потому что `Book` — это полноценная сущность, а `@ElementCollection` используется только для встраиваемых (Embeddable) типов. Использование `OneToMany` обеспечивает корректную работу с внешними ключами и связями.

**Какие аннотации используются для описания связей между сущностями?**

Используются аннотации JPA: `@OneToMany`, `@ManyToOne`, `@ManyToMany`, `@JoinColumn` и `@JoinTable`. Они позволяют явно описать типы связей и таблицы, участвующие в связях.

**Как передаются связанные сущности в DTO?**

Вместо вложенных объектов в DTO передаются только их `id`. Затем в сервисах по этим ID загружаются связанные сущности из репозиториев.

**Почему `PUT` запросы принимают `id` и в теле, и в URL?**

`id` в `URL` — для идентификации ресурса. В теле объекта `id` не обязателен, но может быть добавлен для ясности. В логике сервиса основным идентификатором служит `id` из `URL`.

**Как обрабатываются исключения, если сущность не найдена?**

В сервисах используется `orElseThrow(...)`, где можно выбрасывать `RuntimeException` или `ResponseStatusException` с кодом `404`. Это позволяет клиенту понять, что ресурс не найден.

**Как проверялась работа приложения?**

С помощью `.http` файла в `IntelliJ IDEA`, а также через `Swagger UI`. Оба способа позволяют полноценно протестировать все `CRUD`-операции.

## Вывод

В процессе выполнения лабораторной работы было реализовано полноценное REST API-приложение с использованием Spring Boot, DTO, JPA и MSSQL. Архитектура выстроена по слоям, связи между сущностями оформлены согласно требованиям, а функциональность протестирована через Swagger и встроенные HTTP-запросы. Проект соответствует всем условиям задания и готов к сдаче.
