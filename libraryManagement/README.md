# Лабораторная №2: Spring Boot приложение для управления библиотекой (DAO-реализация)

## Введение

Данный проект представляет собой RESTful приложение, разработанное на Spring Boot, для управления библиотекой. Оно реализует 3 контроллера, 3 сервиса и 5 взаимосвязанных сущностей. Основной упор сделан на архитектурную раздельность, использование DTO вместо прямой работы с Entity, и реализацию собственного слоя DAO на основе `EntityManager`, **без использования Spring Data JPA репозиториев**.

## Цели работы

- Реализовать полноценное CRUD-приложение для управления библиотечными объектами.
- Использовать `EntityManager` через собственные DAO-реализации вместо `JpaRepository`.
- Взаимодействовать с клиентом через DTO.
- Обеспечить тестируемость через Swagger и HTTP-запросы.

## Используемые технологии

- **Spring Boot 3.4.4**
- **Spring Web** (REST API)
- **Jakarta Persistence (JPA)** с `EntityManager`
- **MSSQL Server** (база данных)
- **Lombok** (генерация кода)
- **Swagger (springdoc-openapi)** — визуализация API
- **Maven** — система сборки

## Архитектура проекта

### Слои приложения

- **Controller** — REST API интерфейс
- **Service + Impl** — бизнес-логика
- **Repository** — интерфейсы DAO и их реализации (`DaoImpl`) с `EntityManager`
- **DTO** — объекты передачи данных
- **Entity** — сущности и их связи

### Структура пакетов

```sh
com.example.librarymanagement
├── controller
├── dto
├── entity
├── repository
│   ├── AuthorDao.java
│   ├── AuthorDaoImpl.java
│   └── ...
├── service
│   ├── BookService.java
│   └── impl
│       ├── BookServiceImpl.java
│       └── ...
```

## Сущности и связи

### Author

Сущность, представляющая автора книг. Один автор может написать множество книг.

- Связь: **One-to-Many** с `Book` (в `Book` — внешний ключ `author_id`)

### Publisher

Сущность издателя. Один издатель может издавать множество книг.

- Связь: **One-to-Many** с `Book` (в `Book` — внешний ключ `publisher_id`)

### Category

Сущность категории. Одна категория может быть связана с несколькими книгами, и наоборот.

- Связь: **Many-to-Many** с `Book` через таблицу `book_category`

### Book

Центральная сущность, представляющая книгу.

- Поля: `id`, `title`, `author`, `publisher`, `categories`
- Связи: **Many-to-One** к `Author`, **Many-to-One** к `Publisher`, **Many-to-Many** к `Category`

### Library

Сущность, содержащая список книг.

- Связь: **One-to-Many** с `Book` (или `@ElementCollection`, но в данном случае используются полноценные сущности)

## DAO и EntityManager

Вместо использования `JpaRepository`, для каждой сущности созданы:

- DAO-интерфейсы (`AuthorDao`, `BookDao`, и т.д.)
- Их реализации (`AuthorDaoImpl`, `BookDaoImpl`, и т.д.) с `@PersistenceContext` и `EntityManager`

**Методы DAO:**

- `save(entity)`
- `update(entity)`
- `delete(id)`
- `findById(id)`
- `findAll()`

DAO внедряются в сервисы с помощью конструктора.

## DTO и работа с данными

- Используются отдельные DTO-классы для всех сущностей
- DTO передаёт только нужные поля (например, `authorId`, `publisherId`, `categoryIds`)
- Преобразование между DTO и Entity происходит в `*ServiceImpl`

## CRUD Операции и тестирование

### Способы тестирования

- **Swagger UI:**  
  [http://localhost:8080/swagger-ui/index.html](http://localhost:8080/swagger-ui/index.html)

- **IntelliJ `.http` файл:**  
  `src/main/resources/test.http`

### Примеры поддерживаемых запросов

- `GET /api/authors` — получить всех авторов
- `POST /api/books` — создать книгу
- `PUT /api/publishers/{id}` — обновить издателя
- `DELETE /api/books/{id}` — удалить книгу

## Как запустить проект

1. Установить MSSQL и создать базу `library_DB`
2. Указать логин и пароль в `application.properties`
3. Собрать проект через `Maven`
4. Запустить `LibraryManagementApplication`
5. Открыть Swagger: [http://localhost:8080/swagger-ui/index.html](http://localhost:8080/swagger-ui/index.html)

---

## Ответы на вопросы

**Почему не используется JpaRepository?**  
Чтобы продемонстрировать работу напрямую через `EntityManager` и собственные DAO-реализации, как требует условие лабораторной.

**Зачем использовать DTO?**  
Для отделения слоёв и безопасности. DTO скрывает структуру сущностей, упрощает передачу данных и защищает от утечек бизнес-логики.

**Почему только 3 контроллера?**  
Требование задания — реализовать 3 контроллера, остальные сущности участвуют как вложенные объекты.

**Как обрабатываются связи между сущностями?**  
Связи Many-to-One и Many-to-Many реализуются через JPA аннотации и таблицы связывания.

**Что делать, если сущность не найдена?**  
Методы DAO возвращают `null`, а сервисы могут выбрасывать `RuntimeException`, чтобы клиент получил понятный `404`.

**Как обрабатываются исключения, если сущность не найдена?**

В сервисах используется `orElseThrow(...)`, где можно выбрасывать `RuntimeException` или `ResponseStatusException` с кодом `404`. Это позволяет клиенту понять, что ресурс не найден.

**Как проверялась работа приложения?**

С помощью `.http` файла в `IntelliJ IDEA`, а также через `Swagger UI`. Оба способа позволяют полноценно протестировать все `CRUD`-операции.

## Вывод

В процессе выполнения лабораторной работы было реализовано полноценное REST API-приложение с использованием Spring Boot, DTO, JPA и MSSQL. Архитектура выстроена по слоям, связи между сущностями оформлены согласно требованиям, а функциональность протестирована через Swagger и встроенные HTTP-запросы.